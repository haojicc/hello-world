//
// Created by Hao Ji on 2023/05/28.
//

#ifndef ATCODER_AC303_F_H
#define ATCODER_AC303_F_H
#include <iostream>
#include <vector>
#include "queue"
#include "stack"
#include "set"
#include "unordered_set"
#include "map"
#include "unordered_map"
#include "math.h"
#include "cmath"
#define PI 3.14159265358979

typedef long l;
typedef long long ll;
using namespace std;


void ac303_F(){

}

int main() {
    ac303_F();
    return 0;
}

/*
 モンスターの体力が 0 以下になったら終了するものとして、
 最後から i 番目のターンに魔法 j を使うとその魔法は終了までに min(i,t_j)×d_j のダメージを与えます。
 各ターンで使うべき魔法はこの値が最大となるものです。
 t_j として現れる値をt'_1,<…,<,t'_N' とし N'+1 個の区間 [0,t'_1),[t'_1 ,t'_2),…,[t'_N′−1′ ,t'_N'),[t'_N',∞) を考えます。
 また、i<t_j  となる魔法の添え字の集合を X、そうでない魔法の添え字の集合を Yとします。
 すると、X,Y は i がどの区間に属しているかによって変化します。
 この区間ごとに与えられるダメージの最大値を考えてモンスターの体力が減る様子を O(1) や O(logH) でシミュレーション出来れば本問を解くことが出来ます。

 X,Y に対し、与えられるダメージの最大値は max(i×max_j∈X d_j ,max_j∈Y t_j ×d_j ) です。
 この値の区間内での総和は、max 関数内での前者が後者より大きくなる i を割り算で求め、等差数列の和の公式を使うことで O(1) で求められます。
 これでモンスターの体力が残る場合は減らした上で次の区間へ行き、そうでなければ二分探索等で初めてモンスターの体力が 0 以下になるターンを求めれば良いです。
 オーバーフローに注意してください。




 假设当怪物的健康状况低于0时，游戏就会结束、
 如果在距离结束的第i个回合使用了魔法j，那么到结束时该魔法会造成min(i,t_j)×d_j的伤害。
 每一回合应该使用的魔法是使这个值最大化的魔法。
 让作为t_j出现的值为t'_1,<...,<,t'_N'，并考虑N'+1区间[0,t'_1),[t'_1 ,t'_2),...,[t'_N′-1′ ,t'_N'）,[t'_N',∞）。
 让X为魔法子标的集合，使i<t_j，Y为魔法子标的集合，使i<t_j。
 那么X和Y的变化取决于i属于哪个区间。
 如果我们能通过考虑每个区间造成的最大伤害，在O(1)或O(logH)内模拟出怪物健康的减少，那么这个问题就可以解决了。

 对于X和Y，造成的最大伤害值是max(i×max_j∈X d_j ,max_j∈Y t_j ×d_j )。
 这些数值在区间内的总和可以在O(1)中找到，方法是在max函数中前者大于后者的地方除以i，并使用相等序列之和的公式。
 如果在这之后怪物的力量仍然存在，则减少它并进入下一个区间；否则，找到怪物的力量低于零的第一个回合，例如通过二进制搜索。
 请注意不要溢出。

通过www.DeepL.com/Translator（免费版）翻译
 */
#endif //ATCODER_AC303_F_H
